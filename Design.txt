A simple txt file to keep track of my progress and how I designed this application

The idea is to create a simple key-value database that listens to a port from where the client can send and retrieve data. This is done by java socket programming

The ClientHandler handles the input data from the open socket. Use buffered reader and retrieve data from inputdataStream.
Store the input as a string and extract the command and the args from it and perform the necessary actions. The output is written by the printWriter and sent to the socket via the outputDataStream.
Once the output is sent, the printwriter will flush the buffer (specified by the true argument passed to printwriter)
The first basic implementation covers the simple operations of SET, GET, DELETE and UPDATE
The command BYE will be used to terminate session

The user will be able to create collections and specify any tags associated with them.
They will also have the option to add tags to existing collection and also delete these tags.
Lastly, the existing collections can be also deleted.


<---------------------------------------------------------------------------------->

The KVServer component is used to host the database on a specified port and expose the socket endpoint to the client
Using the thread.sleep to handle terminating of threads as a temporary fix

The KVServices is the main component which handles all the operations and maintains the actual store which is a hashmap.
It also consists of additional helper methods for handling the UUID.

The hashmap is of the format <key, <UUID, value>>
The key is used to identify the record and perform actions as necessary.
The UUID is a unique identifier for every key value insertion, which can be used later on for logging and error debugging.

For storing records we are using a ConcurrentHashMap. HashMap provides good performance for basic operations such as get, set, delete.
The concurrent version is essential for maintaining thread-safety and handling concurrent requests.

The user will have to specify the collection that they want to perform operations something like this:

collection.set {key, value}
collection.get {key}
collection.delete {key}

The next part of the implementation involves grouping records together into collections similar to mongoDB, this can be used to organize data
To achieve this, each collection is a concurrentHashMap which stores individual records (hashmaps) along with the identifier object.
This identifier object consists of key to identify it and a tag, which can be used to store some additional info about the collection.

While creating a new collection by the user. There needs to be a central repo of sorts that will store all the collections.
Instead of a global hashmap storing all the collections, I wanted to create a class just to store the ID of each collections which will be used to reference them.
But I cannot do this as every time the create collection is invoked, the map created will be limited to the scope of the method and will not be available globally.
So I decided to use a static hashmap in the KVStore class to store all the collections. This acts as a central repo of all the collections. Later on I will look into ways to serialize and deserialize data and try to store externally.

